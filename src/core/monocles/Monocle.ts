import { ClassOf } from "../../utilities/types";
import { Document, DocumentChangeOrigin } from "../documents/Document";
import { DocumentEditor } from "../documents/DocumentEditor";
import { Range } from "../documents/Range";
import { TransientDocumentEditor } from "../documents/TransientDocumentEditor";
import { Fragment } from "../fragments/Fragment";
import { InputMapping } from "../mappings/InputMapping";
import { OutputMapping } from "../mappings/OutputMapping";
import { Renderer } from "../renderers/Renderer";
import { UserInterface, UserInterfaceInput, UserInterfaceOutput } from "../user-interfaces/UserInterface";
import { UserInterfaceProvider } from "../user-interfaces/UserInterfaceProvider";
import { MonocleProvider } from "./MonocleProvider";
import { getUnusedUid, MonocleUid } from "./MonocleUid";

export interface MonocleState {
    isActive: boolean;
}

export interface TransientMonocleState {
    editor: TransientDocumentEditor;
}

export abstract class Monocle<
    F extends Fragment = Fragment
> {
    readonly uid: MonocleUid;

    readonly document: Document;
    
    readonly provider: MonocleProvider;

    readonly fragment: F;

    readonly inputMapping: InputMapping<F>;

    readonly outputMapping: OutputMapping;

    readonly userInterface: UserInterface;
    
    readonly renderer: ClassOf<Renderer>;

    readonly state: MonocleState;

    private transientState: TransientMonocleState | null;

    constructor(
        document: Document,
        provider: MonocleProvider,
        fragment: F,
        inputMapping: InputMapping,
        outputMapping: OutputMapping,
        userInterfaceProvider: UserInterfaceProvider,
        renderer: ClassOf<Renderer>,
        initialState?: MonocleState
    ) {
        this.uid = getUnusedUid();

        this.document = document;
        this.provider = provider;
        this.fragment = fragment;
        this.inputMapping = inputMapping;
        this.outputMapping = outputMapping;
        this.userInterface = userInterfaceProvider.provideForMonocle(this);
        this.renderer = renderer;

        this.state = initialState ?? {
            isActive: false
        };

        this.transientState = null;

        this.initialise();
    }

    get range(): Range {
        return this.fragment.range;
    }

    get isTransient(): boolean {
        return this.transientState !== null;
    }

    get isActive(): boolean {
        return this.state?.isActive;
    }

    protected getDocumentEditor(preserveMonocle: boolean): DocumentEditor {
        return this.isTransient
            ? this.transientState!.editor
            : new DocumentEditor(
                this.document,
                {
                    origin: DocumentChangeOrigin.Monocle,
                    monocle: this,
                    isTransientChange: false,
                    preservesMonocle: preserveMonocle
                }
            );
    }

    protected initialise(): void {
        this.initialiseUserInterface();
    }

    protected initialiseUserInterface(): void {
        // Add a model change observer to react to changes in the UI.
        this.userInterface.addModelChangeObserver({
            processChange: modelOutput => {
                this.applyOutputMapping(modelOutput);
            }
        });

        // Initialise the UI with the value generated by the input mapping.
        const userInterfaceInput = this.applyInputMapping();
        this.userInterface.updateModel(userInterfaceInput);
    }

    beginTransientState(): void {
        if (this.isTransient) {
            return;
        }

        // Create a transient state, including a transient editor
        // that can be reused until the transient state is ended.
        this.transientState = {
            editor: new TransientDocumentEditor(
                this.document,
                {
                    origin: DocumentChangeOrigin.Monocle,
                    monocle: this,
                    isTransientChange: true,
                    preservesMonocle: true
                }
            )
        };
    }

    endTransientState(): void {
        if (!this.isTransient) {
            return;
        }

        // Restore the last non-transient content of the editor.
        // This is needed to perform the next non-transient edit.
        const transientEditor = this.transientState!.editor;
        transientEditor.reset();
        transientEditor.restoreInitialContent();

        this.transientState = null;
    }

    applyInputMapping(): UserInterfaceInput {
        return this.inputMapping.processInput({
            document: this.document,
            fragment: this.fragment
        });
    }

    applyOutputMapping(output: UserInterfaceOutput): void {
        this.outputMapping.processOutput(
            output,
            {
                document: this.document,
                documentEditor: this.getDocumentEditor(true),
                fragment: this.fragment
            }
        );
    }
}