import { Document } from "../documents/Document";
import { DocumentEditor } from "../documents/DocumentEditor";
import { Fragment } from "../fragments/Fragment";
import { FragmentProvider } from "../fragments/FragmentProvider";
import { ProgrammableInputMapping } from "../mappings/ProgrammableInputMapping";
import { ProgrammableOutputMapping } from "../mappings/ProgrammableOutputMapping";
import { TemplateSlot, TemplateSlotKey } from "./TemplateSlot";
import { ValuatorValue } from "./valuators/Valuator";


export const DELETE_SLOT = Symbol("Delete template slot");
export type DeleteSlotSymbol = typeof DELETE_SLOT;

export type TemplateDataValue = ValuatorValue | DeleteSlotSymbol;
export type TemplateData = Record<TemplateSlotKey, TemplateDataValue>;

export interface TemplateSettings {
    // Transformer functions that can be used to transform the output data (generated by the input mapping)
    // and the output of the user interface (given to the output mapping).
    transformTemplateData: (data: TemplateData) => any;
    transformUserInterfaceOutput: (output: any) => TemplateData;
}

export function deriveTemplateSettingsFromDefaults<
    S extends TemplateSettings
>(settings: Partial<S>): TemplateSettings {
    return {
        // By default, transformers are identity functions.
        transformTemplateData: (data: TemplateData) => data,
        transformUserInterfaceOutput: (output: any) => output,
        
        ...settings
    };
}

export abstract class Template<
    T extends TemplateSlot = TemplateSlot,
    F extends Fragment = Fragment,
    S extends TemplateSettings = TemplateSettings,
> {
    protected settings: S;
    protected fragmentsToKeysToSlots: Map<F, Map<TemplateSlotKey, T>>;

    protected constructor(
        partialSettings: Partial<S>,
        settingsDeriverFromDefaults: (partialSettings: Partial<S>) => S
    ) {
        this.fragmentsToKeysToSlots = new Map();
        this.settings = settingsDeriverFromDefaults(partialSettings);
    }

    protected shouldCreateSlot(
        key: TemplateSlotKey,
        value: TemplateDataValue,
        fragment: F,
        document: Document,
        transformedOutput: any
    ): boolean {
        // By default, create no new slot.
        return false;
    }

    protected createSlot(
        key: TemplateSlotKey,
        value: TemplateDataValue,
        fragment: F,
        documentEditor: DocumentEditor,
        document: Document,
        transformedOutput: any
    ): void {
        // Do nothing by default.
    }

    protected shouldDeleteSlot(
        slot: T,
        newValue: TemplateDataValue,
        fragment: F,
        document: Document,
        transformedOutput: any
    ): boolean {
        // By default, delete no existing slot.
        return false;
    }

    protected deleteSlot(
        slot: T,
        newValue: TemplateDataValue,
        fragment: F,
        documentEditor: DocumentEditor,
        document: Document,
        transformedOutput: any
    ): void {
        // Do nothing by default.
    }

    protected shouldModifySlot(
        slot: T,
        newValue: TemplateDataValue,
        fragment: F,
        document: Document,
        transformedOutput: any
    ): boolean {
        // By default, always modify slots (assuming they should not be deleted).
        return true;
    }

    protected modifySlot(
        slot: T,
        newValue: TemplateDataValue,
        fragment: F,
        documentEditor: DocumentEditor,
        document: Document,
        transformedOutput: any
    ): void {
        slot.setValue(newValue, documentEditor);
    }

    protected abstract getFragmentProvider(): FragmentProvider<F>;

    protected createTemplateData(
        keysToSlots: Map<TemplateSlotKey, T>,
        fragment: F,
        document: Document
    ): TemplateData {
        const slotKeysToValues: TemplateData = {};
        for (let [key, slot] of keysToSlots.entries()) {
            slotKeysToValues[key] = slot.getValue();
        }

        return slotKeysToValues;
    }

    protected getInputMapping(): ProgrammableInputMapping<F> {
        return new ProgrammableInputMapping<F>(({ fragment, document }) => {
            const keysToSlots = this.fragmentsToKeysToSlots.get(fragment);
            if (!keysToSlots) {
                throw new Error("The slots could not be retrieved: there is no matching fragment.");
            }

            const templateData = this.createTemplateData(keysToSlots, fragment, document);
            return this.settings.transformTemplateData(templateData);
        })
    }

    protected getOutputMapping(): ProgrammableOutputMapping<F> {
        return new ProgrammableOutputMapping<F>(({ fragment, document, documentEditor, output }) => {
            const keysToSlots = this.fragmentsToKeysToSlots.get(fragment);
            if (!keysToSlots) {
                throw new Error("The slots could not be retrieved: there is no matching fragment.");
            }

            const transformedOutput = this.settings.transformUserInterfaceOutput(output);

            for (let [key, value] of Object.entries(transformedOutput)) {
                const slot = keysToSlots.get(key);

                // If the slot does not exist, check whether it should be created (or do nothing).
                // if the slot exists, check whether it should be deleted first, then if it should be modified,
                // and perform the appropriate action (or do nothing).
                if (!slot) {
                    if (this.shouldCreateSlot(key, value, fragment, document, transformedOutput)) {
                        console.info(`Slot with key ${key} will be created (value = ${value}).`);
                        this.createSlot(key, value, fragment, documentEditor, document, transformedOutput);
                    }
                    else {
                        console.warn(`There is no slot with key ${key} and it will not be created.`);
                        continue;
                    }
                }
                else {
                    if (this.shouldDeleteSlot(slot, value, fragment, document, transformedOutput)) {
                        console.info(`Slot with key ${key} will be deleted (value = ${value}).`);
                        this.deleteSlot(slot, value, fragment, documentEditor, document, transformedOutput);
                    }
                    else if (this.shouldModifySlot(slot, value, fragment, document, transformedOutput)) {
                        console.info(`Slot with key ${key} will be modified (value = ${value}).`);
                        this.modifySlot(slot, value, fragment, documentEditor, document, transformedOutput);
                    }
                    else {
                        console.warn(`There is no slot with key ${key} and it will not be created.`);
                        continue;
                    }
                }
            }

            documentEditor.applyEdits();
        })
    }

    // Make template iterables so their fields of interest can be easily inserted
    // in a monocle provider using the spread operator (...).
    get monocleProviderProperties() {
        return {
            fragmentProvider: this.getFragmentProvider(),
            inputMapping: this.getInputMapping(),
            outputMapping: this.getOutputMapping(),
        };
    }
}