import { Document } from "../documents/Document";
import { Fragment } from "../fragments/Fragment";
import { FragmentProvider } from "../fragments/FragmentProvider";
import { ProgrammableInputMapping } from "../mappings/ProgrammableInputMapping";
import { ProgrammableOutputMapping } from "../mappings/ProgrammableOutputMapping";
import { TemplateSlot, TemplateSlotKey } from "./TemplateSlot";
import { TemplateSlotValue } from "./TemplateSlotValuator";

// export interface TemplateData<F extends Fragment = Fragment> {
//     slots: F extends SyntacticFragment
//         ? TextualTemplateSlot
//         : SyntacticTemplateSlot;
// }

export type TemplateData = Record<TemplateSlotKey, TemplateSlotValue>;

// export interface Template<F extends Fragment = Fragment> {
//     fragmentProvider: FragmentProvider<F>;
//     inputMapping: InputMapping<F>
//     outputMapping: OutputMapping<F>;
// }


export interface TemplateSettings {
    // Transformer functions that can be used to transform the output data (generated by the input mapping)
    // and the output of the user interface (given to the output mapping).
    transformTemplateData: (data: TemplateData) => any;
    transformUserInterfaceOutput: (output: any) => TemplateData;
}

export function deriveTemplateSettingsFromDefaults<
    S extends TemplateSettings
>(settings: Partial<S>): TemplateSettings {
    return {
        // By default, transformers are identity functions.
        transformTemplateData: (data: TemplateData) => data,
        transformUserInterfaceOutput: (output: any) => output,
        
        ...settings
    };
}


export abstract class Template<
    F extends Fragment = Fragment,
    S extends TemplateSettings = TemplateSettings
> {
    protected settings: S;
    protected fragmentsToKeysToSlots: Map<F, Map<TemplateSlotKey, TemplateSlot>>;

    protected constructor(
        partialSettings: Partial<S>,
        settingsDeriverFromDefaults: (partialSettings: Partial<S>) => S
    ) {
        this.fragmentsToKeysToSlots = new Map();
        this.settings = settingsDeriverFromDefaults(partialSettings);
    }

    protected abstract getFragmentProvider(): FragmentProvider<F>;

    protected createTemplateData(
        keysToSlots: Map<TemplateSlotKey, TemplateSlot>,
        fragment: F,
        document: Document
    ): TemplateData {
        const slotKeysToValues: TemplateData = {};
        for (let [key, slot] of keysToSlots.entries()) {
            slotKeysToValues[key] = slot.getValue();
        }

        return slotKeysToValues;
    }

    protected getInputMapping(): ProgrammableInputMapping<F> {
        return new ProgrammableInputMapping<F>(({ fragment, document }) => {
            const keysToSlots = this.fragmentsToKeysToSlots.get(fragment);
            if (!keysToSlots) {
                throw new Error("The slots could not be retrieved: there is no matching fragment.");
            }

            const templateData = this.createTemplateData(keysToSlots, fragment, document);
            return this.settings.transformTemplateData(templateData);
        })
    }

    protected getOutputMapping(): ProgrammableOutputMapping<F> {
        return new ProgrammableOutputMapping<F>(({ fragment, documentEditor, output }) => {
            const keysToSlots = this.fragmentsToKeysToSlots.get(fragment);
            if (!keysToSlots) {
                throw new Error("The slots could not be retrieved: there is no matching fragment.");
            }

            const transformedOutput = this.settings.transformUserInterfaceOutput(output);

            for (let [key, value] of Object.entries(transformedOutput)) {
                const slot = keysToSlots.get(key);
                if (!slot) {
                    console.warn(`There is no slot with key ${key}.`);
                    continue;
                }

                slot.setValue(value, documentEditor);
            }

            documentEditor.applyEdits();
        })
    }

    // Make template iterables so their fields of interest can be easily inserted
    // in a monocle provider using the spread operator (...).
    get monocleProviderProperties() {
        return {
            fragmentProvider: this.getFragmentProvider(),
            inputMapping: this.getInputMapping(),
            outputMapping: this.getOutputMapping(),
        };
    }
}