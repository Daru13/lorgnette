import { ClassOf } from "../../utilities/types";
import { Pattern } from "../code-patterns/Pattern";
import { Document } from "../documents/Document";
import { Range } from "../documents/Range";
import { InputMapping } from "../mappings/InputMapping";
import { OutputMapping } from "../mappings/OutputMapping";
import { Renderer } from "../renderers/Renderer";
import { UserInterface, UserInterfaceInput, UserInterfaceOutput } from "../user-interfaces/UserInterface";
import { UserInterfaceProvider } from "../user-interfaces/UserInterfaceProvider";
import { CodeFragmentType } from "./CodeFragmentType";
import { MonocleProvider } from "./MonocleProvider";
import { getUnusedUid, MonocleUid } from "./MonocleUid";

export abstract class Monocle<
    T extends CodeFragmentType = CodeFragmentType
> {
    readonly uid: MonocleUid;

    readonly document: Document;
    
    readonly provider: MonocleProvider;

    readonly pattern: Pattern<T>;

    readonly inputMapping: InputMapping<T>;

    readonly outputMapping: OutputMapping;

    readonly userInterface: UserInterface;
    
    readonly renderer: ClassOf<Renderer>;

    constructor(
        document: Document,
        provider: MonocleProvider,
        pattern: Pattern<T>,
        inputMapping: InputMapping,
        outputMapping: OutputMapping,
        userInterfaceProvider: UserInterfaceProvider,
        renderer: ClassOf<Renderer>,
    ) {
        this.uid = getUnusedUid();

        this.document = document;
        this.provider = provider;
        this.pattern = pattern;
        this.inputMapping = inputMapping;
        this.outputMapping = outputMapping;
        this.userInterface = userInterfaceProvider.provideForMonocle(this);
        this.renderer = renderer;
    }

    get range(): Range {
        return this.pattern.range;
    }

    protected initialise(): void {
        this.initialiseUserInterface();
    }

    protected initialiseUserInterface(): void {
        // Add a model change observer to react to changes in the UI.
        this.userInterface.addModelChangeObserver({
            processChange: modelOutput => {
                this.applyOutputMapping(modelOutput);
            }
        });

        // Initialise the UI with the value generated by the input mapping.
        const userInterfaceInput = this.applyInputMapping();
        this.userInterface.updateModel(userInterfaceInput);
    }

    applyInputMapping(): UserInterfaceInput {
        return this.inputMapping.mapToInput(this.document, this.pattern);
    }

    applyOutputMapping(output: UserInterfaceOutput): void {
        this.outputMapping.processOutput(output, this.document, this.pattern);
    }
}