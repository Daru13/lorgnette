import { FixedThrottler } from "../../utilities/tasks/FixedThrottler";
import { ClassOf } from "../../utilities/types";
import { Document, DocumentChangeOrigin } from "../documents/Document";
import { DocumentEditor } from "../documents/DocumentEditor";
import { Range } from "../documents/Range";
import { TransientDocumentEditor } from "../documents/TransientDocumentEditor";
import { Fragment } from "../fragments/Fragment";
import { BackwardMapping } from "../mappings/BackwardMapping";
import { ForwardMapping } from "../mappings/ForwardMapping";
import { Renderer } from "../renderers/Renderer";
import { RuntimeRequest } from "../runtime/RuntimeRequest";
import { RuntimeResponse } from "../runtime/RuntimeResponse";
import { UserInterface, UserInterfaceInput, UserInterfaceOutput } from "../user-interfaces/UserInterface";
import { UserInterfaceProvider } from "../user-interfaces/UserInterfaceProvider";
import { ProjectionProvider } from "./ProjectionProvider";
import { getUnusedUid, ProjectionUid } from "./ProjectionUid";

export interface ProjectionState {
    isActive: boolean;
    unprocessedRuntimeResponses: RuntimeResponse[];
}

export interface TransientProjectionState {
    editor: TransientDocumentEditor;
}

export class Projection {
    readonly uid: ProjectionUid;

    readonly document: Document;
    
    readonly provider: ProjectionProvider;

    readonly fragment: Fragment;

    readonly runtimeRequests: RuntimeRequest[];

    readonly forwardMapping: ForwardMapping;

    readonly backwardMapping: BackwardMapping;

    readonly userInterface: UserInterface;
    
    readonly renderer: ClassOf<Renderer>;

    readonly state: ProjectionState;

    private transientState: TransientProjectionState | null;

    private runtimeResponseProcesser: FixedThrottler;

    constructor(
        document: Document,
        provider: ProjectionProvider,
        fragment: Fragment,
        runtimeRequests: RuntimeRequest[],
        forwardMapping: ForwardMapping,
        backwardMapping: BackwardMapping,
        userInterfaceProvider: UserInterfaceProvider,
        renderer: ClassOf<Renderer>,
        initialState?: ProjectionState
    ) {
        this.uid = getUnusedUid();

        this.document = document;
        this.provider = provider;
        this.fragment = fragment;
        this.runtimeRequests = runtimeRequests;
        this.forwardMapping = forwardMapping;
        this.backwardMapping = backwardMapping;
        this.userInterface = userInterfaceProvider.provide(this);
        this.renderer = renderer;

        this.state = initialState ?? {
            isActive: false,
            unprocessedRuntimeResponses: []
        };

        this.transientState = null;

        const minTimeBetweenRuntimeResponseProcessing = 100; // ms
        this.runtimeResponseProcesser = new FixedThrottler(
            () => this.processRuntimeResponses(),
            minTimeBetweenRuntimeResponseProcessing
        );

        this.initialise();
    }

    get range(): Range {
        return this.fragment.range;
    }

    get isTransient(): boolean {
        return this.transientState !== null;
    }

    get isActive(): boolean {
        return this.state?.isActive;
    }

    protected getDocumentEditor(preserveProjection: boolean): DocumentEditor {
        return this.isTransient
            ? this.transientState!.editor
            : new DocumentEditor(
                this.document,
                {
                    origin: DocumentChangeOrigin.Projection,
                    projection: this,
                    isTransientChange: false,
                    preservesProjection: preserveProjection
                }
            );
    }

    protected initialise(): void {
        this.initialiseUserInterface();
    }

    protected updateUserInterface(): void {
        const userInterfaceInput = this.applyForwardMapping();
        this.userInterface.updateInput(userInterfaceInput);
    }

    protected initialiseUserInterface(): void {
        // Add a model change observer to react to changes in the UI.
        this.userInterface.addModelChangeObserver({
            processChange: modelOutput => {
                this.applyBackwardMapping(modelOutput);
            }
        });

        // Initialise the UI with the value generated by the forward mapping.
        this.updateUserInterface();
    }

    queueRuntimeResponse(response: RuntimeResponse): void {
        this.state.unprocessedRuntimeResponses.push(response);
        this.runtimeResponseProcesser.runTask();
    }

    protected processRuntimeResponses(): void {
        // Applying the forward mapping to update the UI state
        // will consume all the unprocessed responses.
        this.updateUserInterface();
    }

    beginTransientState(): void {
        if (this.isTransient) {
            return;
        }

        // Create a transient state, including a transient editor
        // that can be reused until the transient state is ended.
        this.transientState = {
            editor: new TransientDocumentEditor(
                this.document,
                {
                    origin: DocumentChangeOrigin.Projection,
                    projection: this,
                    isTransientChange: true,
                    preservesProjection: true
                }
            )
        };
    }

    endTransientState(): void {
        if (!this.isTransient) {
            return;
        }

        // Restore the last non-transient content of the editor.
        // This is needed to perform the next non-transient edit.
        const transientEditor = this.transientState!.editor;
        transientEditor.reset();
        transientEditor.restoreInitialContent();

        this.transientState = null;
    }

    applyForwardMapping(): UserInterfaceInput {
        // Consume all the runtime responses queued since the last application of this mapping.
        const runtimeResponses = this.state.unprocessedRuntimeResponses;
        this.state.unprocessedRuntimeResponses = [];

        return this.forwardMapping.apply({
            document: this.document,
            fragment: this.fragment,
            runtimeResponses: runtimeResponses
        });
    }

    applyBackwardMapping(output: UserInterfaceOutput): void {
        this.backwardMapping.apply({
            userInterfaceOutput: output,
            document: this.document,
            documentEditor: this.getDocumentEditor(true),
            fragment: this.fragment
        });
    }
}